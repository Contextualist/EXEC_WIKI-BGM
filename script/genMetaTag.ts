import { DOMParser } from "jsr:@b-fuze/deno-dom";

const SOURCE_URL = 'https://bgm.tv/wiki/tag/list';
const TARGET_FILE = '../src/lib/bangumiConstant/metaTag.ts';
const SUBJECT_TYPE: Record<number, string> = {
    1: '书籍',
    2: '动画',
    3: '音乐',
    4: '游戏',
    6: '三次元'
}

function generate(r: Record<string, MetaTagKind>): string {
    return `/// File generated by script/${import.meta.url.split('/').pop()}

export interface MetaTagKind {
    [key: string]: MetaTagClass;
}
export interface MetaTagClass {
    tags: string[];
    index: number;
}

export const SUBJECT_TYPE: Record<number, string> = {
${Object.entries(SUBJECT_TYPE).map(([subjectType, subjectTypeName]) => `    ${subjectType}: '${subjectTypeName}',`).join('\n')}
}

${Object.entries(r).map(([typeName, mtg]) => generateMetaTagKind(typeName, mtg)).join('')}

export const META_TAG: { [key: string]: MetaTagKind } = {
${Object.keys(r).map(typeName => `    ${typeName},`).join('\n')}
}
`;
}

function generateMetaTagKind(typeName: string, mtg: MetaTagKind): string {
    return `
const ${typeName}: MetaTagKind = {
${Object.entries(mtg).map(([kind, mtc]) => generateMetaTagClass(kind, mtc)).join('\n')}
}
`;
}

function generateMetaTagClass(kind: string, mtc: MetaTagClass): string {
    return `
    ${kind}: {
        tags: [${mtc.tags.map(tag => `'${tag}'`).join(', ')}],
        index: ${mtc.index},
    },`.slice(1);
}

interface MetaTagKind {
    [key: string]: MetaTagClass;
}
interface MetaTagClass {
    tags: string[];
    index: number;
}

async function fetchPage(subjectType: number) {
    const response = await fetch(`${SOURCE_URL}?type=${subjectType}`);
    const text = await response.text();
    return text;
}

function parsePage(text: string): MetaTagKind {
    const parser = new DOMParser();
    const doc = parser.parseFromString(text, 'text/html');
    const groups = doc.querySelectorAll('ul.line_list_manage > li');
    const r: MetaTagKind = {};
    if (!groups) return r;
    Array.from(groups).forEach(group => {
        const comment = group.querySelector('small')?.textContent;
        if (!comment || !comment.includes('公共标签')) return;
        const index = parseInt(/排序：(\d+)/.exec(comment)?.[1] ?? '-1');
        const kind = group.querySelector('h2.subtitle')?.textContent.trim();
        if (!kind) return;
        const tags = Array.from(group.querySelectorAll('span.tag')).map(a => a.textContent.trim());
        if (tags.length === 0) return;
        r[kind] = { tags, index };
    });
    return r;
}

async function main() {
    const table: Record<string, MetaTagKind> = {};
    for (const subjectType of Object.keys(SUBJECT_TYPE)) {
        const subjectTypeName = SUBJECT_TYPE[parseInt(subjectType)];
        console.log(`fetching ${subjectTypeName}...`);
        const r = await fetchPage(parseInt(subjectType));
        table[subjectTypeName] = parsePage(r);
    }
    const result = generate(table);
    await Deno.writeTextFile(TARGET_FILE, result);
}

main();